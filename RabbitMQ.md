# RabbitMQ

RabbitMQ是一个开源的消息队列中间件，它实现了高级消息队列协议（AMQP）标准。它的作用是在分

布式系统中传递和存储消息，以实现不同应用程序之间的解耦和异步通信。具体来说，RabbitMQ提供了一个可靠的消息传递机制，允许生产者（发送者）将消息发送到一个或多

个称为Exchange的交换机上，然后将消息路由到一个或多个队列中。消费者（接收者）通过订阅队列来

接收和处理消息。

RabbitMQ的作用包括：

1. 解耦：RabbitMQ允许应用程序通过消息传递进行解耦。生产者和消费者之间不存在直接的依赖关

系，它们只需要知道如何与消息队列进行交互即可。

2. 异步通信：应用程序可以通过将消息发送到消息队列中实现异步通信。生产者将消息发送到队列后

立即返回，而不需要等待消费者的响应。

3. 削峰填谷：当生产者的速度超过消费者时，RabbitMQ可以帮助缓冲和平衡消息的流量，从而避免

系统过载。

4. 可靠性传输：RabbitMQ提供了多种机制来确保消息的可靠传输，包括持久化、消息确认和事务机

制等。

5. 消息路由和转发：RabbitMQ支持灵活的消息路由机制，可以根据不同的规则将消息路由到指定的

队列或交换机。

6. 扩展性和高可用性：通过构建RabbitMQ集群，可以实现高可用性和可扩展性，确保系统在节点故

障时仍能正常运行。

总之，RabbitMQ是一个功能强大的消息队列中间件，广泛应用于微服务架构、分布式系统、异步任务

处理、日志收集和实时数据处理等场景，提供了可靠、灵活和高效的消息传递机制。



## 主要组件

1. Producer（生产者）：生产者是消息的发送方，它将消息发送到RabbitMQ的交换机上。
2. Exchange（交换机）：交换机接收来自生产者的消息，并根据特定的规则将消息路由到一个或多

个队列中。常见的交换机类型有直连交换机（Direct Exchange）、主题交换机（Topic 

Exchange）、扇形交换机（Fanout Exchange）和头交换机（Headers Exchange）。

3. Queue（队列）：队列是RabbitMQ用于存储消息的容器。消费者可以订阅队列，从队列中获取消

息进行处理。

4. Binding（绑定）：绑定是交换机和队列之间的关联关系，它定义了消息的路由规则。绑定规定了

消息从交换机发送到哪个队列。

5. Consumer（消费者）：消费者从队列中接收消息，并处理这些消息。
6. Connection（连接）：连接是应用程序与RabbitMQ服务器之间的TCP连接。
7. Channel（通道）：通道是建立在连接之上的虚拟连接，用于在应用程序和RabbitMQ服务器之间

进行数据传输。通过使用通道，可以在同一个连接上创建多个独立的会话。

8. Virtual Host（虚拟主机）：虚拟主机是逻辑上的概念，用于将RabbitMQ服务器分割为多个独立的

部分，类似于操作系统中的命名空间。每个虚拟主机拥有自己的交换机、队列和绑定等。

9. Broker（代理）：代理是RabbitMQ服务器的核心组件，负责接收、路由和传递消息。它处理与生

产者和消费者之间的通信，并通过交换机将消息路由到队列。

以上是RabbitMQ的主要组件，它们共同构成了一个完整的消息队列系统，实现了可靠的消息传递和处

理。



## **RabbitMQ**有几种工作模式

1.**simple**模式（即最简单的收发模式）

![企业微信截图_17172174512423](assets/企业微信截图_17172174512423.png)

​	消息产生消息，将消息放入队列

​	消息的消费者(consumer) 监听 消息队列,如果队列中有消息,就消费掉,消息被拿走后,自动从队列中

​	删除(隐患 消息可能没有被消费者正确处理,已经从队列中消失了,造成消息的丢失，这里可以设置成手动的ack,	但如果设置成手动ack，处理完后要及时发送ack消息给队列，否则会造成内存溢出)。



2. **work**工作模式(资源的竞争)

   ![企业微信截图_17172174545931](assets/企业微信截图_17172174545931.png)

   消息产生者将消息放入队列消费者可以有多个,消费者1,消费者2同时监听同一个队列,消息被消费。

   C1 C2共同争抢当前的消息队列内容,谁先拿到谁负责消费消息(隐患：高并发情况下,默认会产生某

   一个消息被多个消费者共同使用,可以设置一个开关(syncronize) 保证一条消息只能被一个消费者使

   用)。

   

3.  **publish/subscribe**发布订阅(共享资源)

   ![企业微信截图_17172174567474](assets/企业微信截图_17172174567474.png)

   每个消费者监听自己的队列；

   生产者将消息发给broker，由交换机将消息转发到绑定此交换机的每个队列，每个绑定交换机的队

   列都将接收到消息。

   

4. **routing**路由模式

   ![企业微信截图_17172174599711](assets/企业微信截图_17172174599711.png)

   消息生产者将消息发送给交换机按照路由判断,路由是字符串(info) 当前产生的消息携带路由字符(对

   象的方法),交换机根据路由的key,只能匹配上路由key对应的消息队列,对应的消费者才能消费消息;根据业务功能定义路由字符串

   从系统的代码逻辑中获取对应的功能字符串,将消息任务扔到对应的队列中。

   业务场景:error 通知;EXCEPTION;错误通知的功能;传统意义的错误通知;客户通知;利用key路由,可以

   将程序中的错误封装成消息传入到消息队列中,开发者可以自定义消费者,实时接收错误;



## 如何保证消息不被重复消费

分析重复消费原因

**生产时消息重复**

​	由于生产者发送消息给MQ，在MQ确认的时候出现了网络波动，生产者没有收到确认，实际上MQ

已经接收到了消息。这时候生产者就会重新发送一遍这条消息。生产者中如果消息未被确认，或确

认失败，我们可以使用定时任务+（redis/db）来进行消息重试。

**消费时消息重复**

​	消费者消费成功后，再给MQ确认的时候出现了网络波动，MQ没有接收到确认，为了保证消息被

消费，MQ就会继续给消费者投递之前的消息。这时候消费者就接收到了两条一样的消息。

解决方案

- ​	让每个消息携带一个全局的唯一ID，即可保证消息的幂等性
- ​	消费者获取到消息后先根据id去查询redis/db是否存在该消息。
- ​	如果不存在，则正常消费，消费完毕后写入redis/db。
- ​	如果存在，则证明消息被消费过，直接丢弃。

# RabbitMQ的优缺点



![image-20240527150631759](assets/image-20240527150631759.png)

